<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cờ Tướng</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
    /* Đường dẫn đến file ảnh cục bộ của bạn */
    --board-bg: url('./images/background_cotuong_galaxy.jpg'); 
    --line-color: #676767; /* Đổi màu đường kẻ sang trắng để dễ nhìn trên nền tối */
    --red-piece: #ff4d4d;
    --black-piece: #00eeee; /* Đổi màu quân đen sang xanh neon nếu nền quá tối */
    }
    .board-container {
    position: relative;
    width: 100%;
    aspect-ratio: 9 / 10;
    /* Cập nhật thuộc tính background để ảnh hiển thị đẹp hơn */
    background-image: var(--board-bg);
    background-size: cover;
    background-position: center;
    border: 4px solid #444;
    box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    display: grid;
    grid-template-columns: repeat(9, 11.11%);
    grid-template-rows: repeat(10, 10%);
    user-select: none;
    }

/* Sửa màu đường kẻ trong SVG */
    .board-svg g {
    stroke: var(--line-color) !important;
    stroke-opacity: 0.8;
    }

/* Sửa màu chữ SỞ HÀ - HÁN GIỚI để nổi bật trên nền ảnh */
    .board-svg text {
    fill: #fff !important;
    }


    body {
        background-color: #0f172a; /* Nền ngoài tối màu */
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        touch-action: manipulation;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        padding: 10px;
        color: white;
    }

    .game-wrapper {
        position: relative;
        width: 100%;
        max-width: 480px;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .board-container {
        position: relative;
        width: 100%;
        aspect-ratio: 9 / 10;
        /* Sử dụng biến đã khai báo ở :root hoặc chèn trực tiếp link ảnh tại đây */
        background-image: var(--board-bg); 
        background-size: cover;
        background-position: center;
        border: 4px solid #334155;
        box-shadow: 0 0 30px rgba(0,0,0,0.5);
        display: grid;
        grid-template-columns: repeat(9, 11.11%);
        grid-template-rows: repeat(10, 10%);
        user-select: none;
    }

        /* Làm mờ nhẹ lớp nền để quân cờ nổi bật hơn */
        .board-container::before {
            content: "";
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.2); 
            z-index: 1;
        }

        .board-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .cell {
            position: relative;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .piece {
            width: 88%;
            height: 88%;
            border-radius: 50%;
            background-color: #1e293b; /* Quân cờ tối màu kiểu sci-fi */
            border: 2px solid #64748b;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.25rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
            z-index: 20;
            transition: left 0.4s, top 0.4s, transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            position: absolute; /* Quan trọng để tính toán vị trí theo tọa độ */
            will-change: transform, left, top;
        }

        .piece.moving {
            z-index: 100;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }



        .piece.red { color: var(--red-piece); border-color: var(--red-piece); box-shadow: 0 0 10px rgba(255,77,77,0.3); }
        .piece.black { color: var(--black-piece); border-color: var(--black-piece); box-shadow: 0 0 10px rgba(0,229,255,0.3); }
        .piece.selected { transform: scale(1.15); box-shadow: 0 0 20px #facc15; border-width: 3px; z-index: 30; }

        .hint {
            width: 14px;
            height: 14px;
            background-color: rgba(34, 197, 94, 0.8);
            border-radius: 50%;
            z-index: 15;
            box-shadow: 0 0 8px #22c55e;
        }

        .captured-container {
            min-height: 40px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px dashed #475569;
            border-radius: 6px;
            padding: 4px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
            align-items: center;
        }
        .last-move {
            background-color: rgba(255, 255, 0, 0.2) !important;
            border: 2px solid rgba(255, 255, 0, 0.5);
            border-radius: 50%;
        }
        /* Xoay toàn bộ container bàn cờ */
        .flipped {
            transform: rotate(180deg);
        }

        /* Xoay ngược lại các quân cờ và text để chúng không bị ngược chữ */
        .flipped .piece, 
        .flipped .hint,
        .flipped .board-svg text {
            transform: rotate(180deg);
        }

        /* Hiệu ứng chuyển cảnh khi xoay */
        .board-container {
            transition: transform 0.6s ease-in-out;
        }
        .waiting-overlay {
    position: absolute;
    inset: 0;
    background: rgba(15, 23, 42, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 150;
    border-radius: 1.5rem;
}
.blink {
    animation: blinker 1.5s linear infinite;
}
@keyframes blinker {
    50% { opacity: 0; }
}
    </style>
    <!-- STYLE -->
    <style>
    #online-info {
    position: fixed;
    top: 15px;
    right: 15px;
    left: 50%;
    z-index: 100;
    margin: 0;
    display: none; /* Sẽ được điều khiển bằng JS */
}

#online-info .glass-card {
    height: 100%;
    width: max-content;
    background: rgba(0, 0, 0, 0.277);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0);
    border-radius: 12px;
    padding: 8px 15px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    display: inline-flex;
    flex-direction: row;
    align-items: center;
}

#display-peer-id {
    font-family: 'Monaco', 'Consolas', monospace;
    font-size: 10px;
    font-weight: 800;
    text-align: center;
    color: #00eeee; /* Màu xanh neon cho nổi bật */
    letter-spacing: 1px;
    margin-left: 7px;
}

.id-label {
    font-size: 10px;
    text-align: center;
    color: rgba(255, 255, 255, 0.6);
    letter-spacing: 1px;
}
    </style>
</head>
<body>

    <div class="game-wrapper">
        <header class="text-center flex justify-between items-center px-2">
            <h1 class="text-xl font-bold text-gray-800">Cờ Tướng</h1>
            <div id="game-status" class="text-sm font-bold bg-white px-3 py-1 rounded-full shadow-sm text-red-600 border border-red-200">Lượt: Đỏ</div>
        </header>
        <!-- ---------------------- -->
       <div id="online-info" class="hidden">
    <div class="glass-card">
        <span class="id-label">Phòng:</span>
        <span id="display-peer-id">....</span>
    </div>
</div>
<!-- -------------------------------- -->
        <div class="flex flex-col gap-1">
            <div class="flex justify-between items-center px-1">
                <span class="text-[10px] font-bold text-gray-500 uppercase tracking-wider">Quân Đen đã ăn:</span>
                <span id="black-score" class="text-[10px] font-mono text-gray-400">0 quân</span>
            </div>
            <div id="captured-red" class="captured-container"></div>
        </div>

        <div class="relative">

            <div id="waiting-msg" class="waiting-overlay hidden">
                <span class="text-blue-400 font-bold text-lg blink">ĐANG CHỜ ĐỐI THỦ...</span>
            </div>
            <div id="river-alert" class="absolute inset-0 flex items-center justify-center pointer-events-none z-[100] opacity-0 transition-opacity duration-500">
                <span class="bg-red-600 text-white px-6 py-2 rounded-full text-2xl font-bold shadow-2xl ring-4 ring-white">CHIẾU TƯỚNG!</span>
            </div>
            
            <div id="board" class="board-container">
                <svg class="board-svg" viewBox="0 0 90 100" preserveAspectRatio="none">
                    <g stroke="#333" stroke-width="0.5">
                        <line x1="5" y1="5" x2="5" y2="95" />
                        <line x1="15" y1="5" x2="15" y2="45" /> <line x1="15" y1="55" x2="15" y2="95" />
                        <line x1="25" y1="5" x2="25" y2="45" /> <line x1="25" y1="55" x2="25" y2="95" />
                        <line x1="35" y1="5" x2="35" y2="45" /> <line x1="35" y1="55" x2="35" y2="95" />
                        <line x1="45" y1="5" x2="45" y2="45" /> <line x1="45" y1="55" x2="45" y2="95" />
                        <line x1="55" y1="5" x2="55" y2="45" /> <line x1="55" y1="55" x2="55" y2="95" />
                        <line x1="65" y1="5" x2="65" y2="45" /> <line x1="65" y1="55" x2="65" y2="95" />
                        <line x1="75" y1="5" x2="75" y2="45" /> <line x1="75" y1="55" x2="75" y2="95" />
                        <line x1="85" y1="5" x2="85" y2="95" />
                        <line x1="5" y1="5" x2="85" y2="5" />
                        <line x1="5" y1="15" x2="85" y2="15" />
                        <line x1="5" y1="25" x2="85" y2="25" />
                        <line x1="5" y1="35" x2="85" y2="35" />
                        <line x1="5" y1="45" x2="85" y2="45" />
                        <line x1="5" y1="55" x2="85" y2="55" />
                        <line x1="5" y1="65" x2="85" y2="65" />
                        <line x1="5" y1="75" x2="85" y2="75" />
                        <line x1="5" y1="85" x2="85" y2="85" />
                        <line x1="5" y1="95" x2="85" y2="95" />
                        <line x1="35" y1="5" x2="55" y2="25" /> <line x1="55" y1="5" x2="35" y2="25" />
                        <line x1="35" y1="75" x2="55" y2="95" /> <line x1="55" y1="75" x2="35" y2="95" />
                    </g>
                    <text x="23" y="51.5" font-size="4" fill="#666" font-weight="bold">SỞ HÀ</text>
                    <text x="53" y="51.5" font-size="4" fill="#666" font-weight="bold">HÁN GIỚI</text>
                </svg>
            </div>
        </div>

        <div class="flex flex-col gap-1">
            <div class="flex justify-between items-center px-1">
                <span class="text-[10px] font-bold text-red-700 uppercase tracking-wider">Quân Đỏ đã ăn:</span>
                <span id="red-score" class="text-[10px] font-mono text-gray-400">0 quân</span>
            </div>
            <div id="captured-black" class="captured-container"></div>
        </div>

        <div class="mt-2 text-center">
            <button id="reset-btn" class="bg-gray-800 hover:bg-black text-white px-10 py-2 rounded shadow text-sm font-bold transition">CHƠI MỚI</button>
        </div>
    </div>

    <div id="alert-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden z-[200] flex items-center justify-center p-4">
        <div class="bg-white p-6 rounded shadow-2xl text-center max-w-sm w-full border-t-4 border-blue-600">
            <h2 id="alert-title" class="text-xl font-bold mb-2">Thông báo</h2>
            <p id="alert-message" class="mb-6 text-gray-600 text-sm"></p>
            <button onclick="closeAlert()" class="bg-blue-600 hover:bg-blue-700 text-white px-12 py-2 rounded font-bold transition">OK</button>
        </div>
    </div>

    <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-80 hidden z-[250] flex items-center justify-center p-4">
    <div class="bg-slate-800 p-6 rounded-xl shadow-2xl text-center max-w-sm w-full border border-slate-600">
        <div class="mb-4 text-yellow-400">
            <svg class="w-12 h-12 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="浸4 4a8 8 0 1111.314 0z"></path>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3"></path>
            </svg>
        </div>
        <h2 class="text-xl font-bold mb-2 text-white">Yêu cầu chơi lại</h2>
        <p id="confirm-message" class="mb-6 text-slate-300 text-sm">Đối thủ muốn làm mới bàn cờ để bắt đầu ván mới. Bạn có đồng ý không?</p>
        <div class="flex gap-3">
            <button id="confirm-yes" class="flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-bold transition">ĐỒNG Ý</button>
            <button id="confirm-no" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded font-bold transition">TỪ CHỐI</button>
        </div>
    </div>
</div>
    <script>
        const RED = 'red';
        const BLACK = 'black';
        const PIECES = {
            KING: { red: '帥', black: '將' },
            ADVISOR: { red: '仕', black: '士' },
            ELEPHANT: { red: '相', black: '象' },
            HORSE: { red: '馬', black: '馬' },
            CHARIOT: { red: '車', black: '車' },
            CANNON: { red: '砲', black: '炮' },
            SOLDIER: { red: '兵', black: '卒' }
        };

        let boardState = Array(10).fill(null).map(() => Array(9).fill(null));
        let turn = RED;
        let selected = null;
        let hints = [];
        let captured = { red: [], black: [] };
        let lastMove = null;
    

        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('game-status');
        const capRedEl = document.getElementById('captured-red');
        const capBlackEl = document.getElementById('captured-black');
        const redScoreEl = document.getElementById('red-score');
        const blackScoreEl = document.getElementById('black-score');

        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode'); // 'online' hoặc 'offline'
        const action = urlParams.get('action'); // 'create' hoặc 'join'
        const remotePeerId = urlParams.get('peerId');

        // --- BIẾN TOÀN CỤC BỔ SUNG ---
let peer;
let conn;
let myColor = RED; // Mặc định là Red cho offline
let isOnline = false;

// --- KHỞI TẠO PEERJS ---
if (mode === 'online') {
    isOnline = true;
    document.getElementById('online-info').classList.remove('hidden');

    // Tạo ID ngẫu nhiên 4 chữ số từ 1000 đến 9999
    const customId = Math.floor(1000 + Math.random() * 9000).toString();
    
    // Khởi tạo Peer với ID 4 chữ số
    peer = new Peer(customId); 

    peer.on('open', (id) => {
        console.log('ID của bạn là: ' + id);
    // Hiển thị khung ID
    document.getElementById('online-info').style.display = 'block'; 
    document.getElementById('display-peer-id').innerText = id;

        if (action === 'create') {
            myColor = RED;
            // Thông báo cho người tạo phòng
            document.getElementById('waiting-msg').classList.remove('hidden'); // Hiện thông báo chờ
        } else if (action === 'join') {
            myColor = BLACK;
            render();
            // Nếu nhấn Join mà chưa có ID, có thể dùng prompt để hỏi
            const idToJoin = remotePeerId || prompt("Nhập mã phòng 4 chữ số:");
            if (idToJoin) {
                document.getElementById('display-peer-id').innerText = idToJoin;
                connectToPeer(idToJoin);
            }
        }
    });

    // Lắng nghe kết nối (dành cho Host)
    peer.on('connection', (connection) => {
        conn = connection;
        setupConnHandlers();
        showAlert("Sẵn sàng!", "Đối thủ đã kết nối. Bạn cầm quân Đỏ đi trước.");
    });

    // Xử lý lỗi (ví dụ ID đã tồn tại)
    peer.on('error', (err) => {
        if (err.type === 'unavailable-id') {
            alert("Mã phòng này đã bị trùng, vui lòng làm mới trang để lấy mã khác.");
        } else {
            console.error(err);
        }
    });
}
        function initGame() {
            boardState = Array(10).fill(null).map(() => Array(9).fill(null));
            setupRow(0, BLACK, ['CHARIOT', 'HORSE', 'ELEPHANT', 'ADVISOR', 'KING', 'ADVISOR', 'ELEPHANT', 'HORSE', 'CHARIOT']);
            setupRow(2, BLACK, [null, 'CANNON', null, null, null, null, null, 'CANNON', null]);
            setupRow(3, BLACK, ['SOLDIER', null, 'SOLDIER', null, 'SOLDIER', null, 'SOLDIER', null, 'SOLDIER']);
            setupRow(9, RED, ['CHARIOT', 'HORSE', 'ELEPHANT', 'ADVISOR', 'KING', 'ADVISOR', 'ELEPHANT', 'HORSE', 'CHARIOT']);
            setupRow(7, RED, [null, 'CANNON', null, null, null, null, null, 'CANNON', null]);
            setupRow(6, RED, ['SOLDIER', null, 'SOLDIER', null, 'SOLDIER', null, 'SOLDIER', null, 'SOLDIER']);
            turn = RED;
            selected = null;
            hints = [];
            captured = { red: [], black: [] };
            if (isOnline && (!conn || !conn.open)) {
        document.getElementById('waiting-msg').classList.remove('hidden');
    } else {
        document.getElementById('waiting-msg').classList.add('hidden');
    }
            render();
            updateStatus();
        }

        function setupRow(r, color, rowPieces) {
            rowPieces.forEach((p, c) => { if (p) boardState[r][c] = { type: p, color }; });
        }

        function showRiverAlert() {
            const alertEl = document.getElementById('river-alert');
            alertEl.classList.remove('opacity-0');
            alertEl.classList.add('opacity-100');
            setTimeout(() => {
                alertEl.classList.remove('opacity-100');
                alertEl.classList.add('opacity-0');
            }, 500);
        }

        function render() {
            if (isOnline && myColor === BLACK) {
                boardEl.classList.add('flipped');
            } else {
                boardEl.classList.remove('flipped');
            }
            // Chỉ xóa các thẻ .cell, giữ lại SVG bàn cờ
            const oldCells = boardEl.querySelectorAll('.cell');
            oldCells.forEach(cell => cell.remove());

        
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r; // Lưu tọa độ vào dataset
                    cell.dataset.c = c;
                    cell.id = `cell-${r}-${c}`; // Gán ID để truy vấn nhanh

                    if (lastMove && ((lastMove.fromR === r && lastMove.fromC === c) || (lastMove.toR === r && lastMove.toC === c))) {
                        cell.classList.add('last-move');
                    }
                    cell.onclick = () => handleCellClick(r, c);
                    const piece = boardState[r][c];
                    if (piece) {
                        const pEl = document.createElement('div');
                        pEl.className = `piece ${piece.color} ${selected && selected.r === r && selected.c === c ? 'selected' : ''}`;
                        pEl.innerText = PIECES[piece.type][piece.color];
                        pEl.id = `piece-${r}-${c}`;
                        cell.appendChild(pEl);
                    }
                    if (hints.some(h => h.r === r && h.c === c)) {
                        const hint = document.createElement('div');
                        hint.className = 'hint';
                        cell.appendChild(hint);
                    }
                    boardEl.appendChild(cell);
                }
            }
            
            capRedEl.innerHTML = captured.red.map(p => `<div class="captured-piece text-red-600">${PIECES[p.type][RED]}</div>`).join('');
            capBlackEl.innerHTML = captured.black.map(p => `<div class="captured-piece text-gray-800">${PIECES[p.type][BLACK]}</div>`).join('');
            redScoreEl.innerText = `${captured.black.length} quân`;
            blackScoreEl.innerText = `${captured.red.length} quân`;
        }

        function handleCellClick(r, c) {
    // 1. Nếu là online, kiểm tra xem đối thủ đã kết nối chưa
    if (isOnline && (!conn || !conn.open)) {
        console.log("Chờ đối thủ kết nối...");
        return; 
    }

    if (selected && hints.some(h => h.r === r && h.c === c)) {
        movePiece(selected.r, selected.c, r, c);
        return;
    }

    const piece = boardState[r][c];
    
    // 2. Kiểm tra quyền nhấc quân:
    // - Phải đúng lượt (turn)
    // - Nếu online: Phải đúng màu quân của mình (myColor)
    if (piece && piece.color === turn) {
        if (isOnline && piece.color !== myColor) {
            return; // Không cho phép nhấc quân đối thủ
        }
        
        selected = { r, c };
        hints = getValidMoves(r, c);
        render();
    } else {
        selected = null;
        hints = [];
        render();
    }
}

        function movePiece(fromR, fromC, toR, toC) {
       // Nếu là online, chỉ cho phép đi khi tới lượt và đúng màu quân của mình
            if (isOnline) {
                if (boardState[fromR][fromC].color !== myColor) return;
                if (turn !== myColor) return;

                // Gửi nước đi sang cho đối thủ
                if (conn && conn.open) {
                conn.send({
                   type: 'MOVE',
                   fromR, fromC, toR, toC
                    });
                }
            }
            executeMove(fromR, fromC, toR, toC);
        }   

        function executeMove(fromR, fromC, toR, toC) {
    const pieceEl = document.querySelector(`#cell-${fromR}-${fromC} .piece`);
    const targetCell = document.getElementById(`cell-${toR}-${toC}`);

    if (pieceEl && targetCell) {
        // 1. Tính toán khoảng cách di chuyển
        const fromRect = pieceEl.getBoundingClientRect();
        const toRect = targetCell.getBoundingClientRect();
        
        let deltaX = toRect.left - fromRect.left;
        let deltaY = toRect.top - fromRect.top;

        const isFlipped = boardEl.classList.contains('flipped');

        if (isFlipped) {
            // Đảo ngược hướng di chuyển vì tọa độ màn hình không đổi khi xoay CSS
            deltaX = deltaX;
            deltaY = deltaY;
        }

        pieceEl.classList.add('moving');
        
        // GIẢI PHÁP: Nếu là quân đen (flipped), giữ rotate(180deg) trong lúc translate
        if (isFlipped) {
            pieceEl.style.transform = `rotate(180deg) translate(${deltaX}px, ${deltaY}px)`;
        } else {
            pieceEl.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
        }

        // 3. Đợi animation kết thúc (0.4s) rồi mới cập nhật dữ liệu thực
        setTimeout(() => {
            const mover = boardState[fromR][fromC];
            const target = boardState[toR][toC];
            
            if (target) {
                captured[target.color].push(target);
            }
            
            boardState[toR][toC] = mover;
            boardState[fromR][fromC] = null;
            
            lastMove = { fromR, fromC, toR, toC };
            selected = null;
            hints = [];
            turn = (turn === RED ? BLACK : RED);
            
            render(); // Vẽ lại toàn bộ bàn cờ sau khi đi xong
            checkGameState();
            updateStatus();
        }, 400); 
    } else {
        // Trường hợp không tìm thấy phần tử (fallback)
        performLogicalMove(fromR, fromC, toR, toC);
    }
}

function performLogicalMove(fromR, fromC, toR, toC) {
    const mover = boardState[fromR][fromC];
    const target = boardState[toR][toC];
    if (target) captured[target.color].push(target);
    boardState[toR][toC] = mover;
    boardState[fromR][fromC] = null;
    turn = (turn === RED ? BLACK : RED);
    render();
}

        function getValidMoves(r, c, checkKingSafety = true) {
            const piece = boardState[r][c];
            if (!piece) return [];
            let moves = [];
            switch (piece.type) {
                case 'KING': moves = getKingMoves(r, c, piece.color); break;
                case 'ADVISOR': moves = getAdvisorMoves(r, c, piece.color); break;
                case 'ELEPHANT': moves = getElephantMoves(r, c, piece.color); break;
                case 'HORSE': moves = getHorseMoves(r, c, piece.color); break;
                case 'CHARIOT': moves = getChariotMoves(r, c, piece.color); break;
                case 'CANNON': moves = getCannonMoves(r, c, piece.color); break;
                case 'SOLDIER': moves = getSoldierMoves(r, c, piece.color); break;
            }
            if (checkKingSafety) {
                moves = moves.filter(m => {
                    const temp = boardState[m.r][m.c];
                    boardState[m.r][m.c] = piece;
                    boardState[r][c] = null;
                    const safe = !isKingInCheck(piece.color) && !isFaceToFace();
                    boardState[r][c] = piece;
                    boardState[m.r][m.c] = temp;
                    return safe;
                });
            }
            return moves;
        }

        function inBounds(r, c) { return r >= 0 && r < 10 && c >= 0 && c < 9; }
        function isEmpty(r, c) { return boardState[r][c] === null; }
        function isEnemy(r, c, myColor) { return boardState[r][c] && boardState[r][c].color !== myColor; }
        function isFriend(r, c, myColor) { return boardState[r][c] && boardState[r][c].color === myColor; }
        function inPalace(r, c, color) {
            return (c >= 3 && c <= 5) && (color === RED ? (r >= 7 && r <= 9) : (r >= 0 && r <= 2));
        }

        function getKingMoves(r, c, color) {
            return [[0,1],[0,-1],[1,0],[-1,0]].map(s => ({r: r+s[0], c: c+s[1]}))
                .filter(m => inBounds(m.r, m.c) && inPalace(m.r, m.c, color) && !isFriend(m.r, m.c, color));
        }

        function getAdvisorMoves(r, c, color) {
            return [[1,1],[1,-1],[-1,1],[-1,-1]].map(s => ({r: r+s[0], c: c+s[1]}))
                .filter(m => inBounds(m.r, m.c) && inPalace(m.r, m.c, color) && !isFriend(m.r, m.c, color));
        }

        function getElephantMoves(r, c, color) {
            const moves = [];
            [[2,2],[2,-2],[-2,2],[-2,-2]].forEach(s => {
                const tr = r + s[0], tc = c + s[1];
                const mr = r + s[0]/2, mc = c + s[1]/2;
                const overRiver = color === RED ? tr < 5 : tr > 4;
                if (inBounds(tr, tc) && !overRiver && isEmpty(mr, mc) && !isFriend(tr, tc, color)) moves.push({r: tr, c: tc});
            });
            return moves;
        }

        function getHorseMoves(r, c, color) {
            const moves = [];
            const steps = [{t:[-2,-1],b:[-1,0]},{t:[-2,1],b:[-1,0]},{t:[2,-1],b:[1,0]},{t:[2,1],b:[1,0]},{t:[-1,-2],b:[0,-1]},{t:[1,-2],b:[0,-1]},{t:[-1,2],b:[0,1]},{t:[1,2],b:[0,1]}];
            steps.forEach(s => {
                const tr = r+s.t[0], tc = c+s.t[1];
                const br = r+s.b[0], bc = c+s.b[1];
                if (inBounds(tr, tc) && isEmpty(br, bc) && !isFriend(tr, tc, color)) moves.push({r: tr, c: tc});
            });
            return moves;
        }

        function getChariotMoves(r, c, color) {
            const moves = [];
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(d => {
                let nr = r+d[0], nc = c+d[1];
                while(inBounds(nr, nc)) {
                    if (isEmpty(nr, nc)) moves.push({r: nr, c: nc});
                    else { if (isEnemy(nr, nc, color)) moves.push({r: nr, c: nc}); break; }
                    nr += d[0]; nc += d[1];
                }
            });
            return moves;
        }

        function getCannonMoves(r, c, color) {
            const moves = [];
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(d => {
                let nr = r+d[0], nc = c+d[1], hasPlatform = false;
                while(inBounds(nr, nc)) {
                    if (!hasPlatform) {
                        if (isEmpty(nr, nc)) moves.push({r: nr, c: nc}); else hasPlatform = true;
                    } else {
                        if (!isEmpty(nr, nc)) { if (isEnemy(nr, nc, color)) moves.push({r: nr, c: nc}); break; }
                    }
                    nr += d[0]; nc += d[1];
                }
            });
            return moves;
        }

        function getSoldierMoves(r, c, color) {
            const moves = [];
            const forward = color === RED ? -1 : 1;
            if (inBounds(r + forward, c) && !isFriend(r + forward, c, color)) moves.push({r: r + forward, c});
            if ((color === RED ? r < 5 : r > 4)) {
                if (inBounds(r, c + 1) && !isFriend(r, c + 1, color)) moves.push({r, c: c + 1});
                if (inBounds(r, c - 1) && !isFriend(r, c - 1, color)) moves.push({r, c: c - 1});
            }
            return moves;
        }

        function findKing(color) {
            for (let r = 0; r < 10; r++) for (let c = 0; c < 9; c++) {
                const p = boardState[r][c]; if (p && p.type === 'KING' && p.color === color) return {r, c};
            }
            return null;
        }

        function isKingInCheck(color) {
            const kp = findKing(color); if (!kp) return false;
            const enemy = color === RED ? BLACK : RED;
            for (let r = 0; r < 10; r++) for (let c = 0; c < 9; c++) {
                const p = boardState[r][c];
                if (p && p.color === enemy) {
                    if (getValidMoves(r, c, false).some(m => m.r === kp.r && m.c === kp.c)) return true;
                }
            }
            return false;
        }

        function isFaceToFace() {
            const rk = findKing(RED), bk = findKing(BLACK);
            if (!rk || !bk || rk.c !== bk.c) return false;
            for (let r = Math.min(rk.r, bk.r) + 1; r < Math.max(rk.r, bk.r); r++) if (boardState[r][rk.c]) return false;
            return true;
        }

        function checkGameState() {
            const enemyColor = turn;
            if (isKingInCheck(enemyColor)) {
                let canEscape = false;
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 9; c++) {
                        const p = boardState[r][c];
                        if (p && p.color === enemyColor && getValidMoves(r, c, true).length > 0) { 
                            canEscape = true; break; 
                        }
                    }
                    if (canEscape) break;
                }

                if (!canEscape) {
                    showAlert("CHIẾU BÍ!", `Bên ${enemyColor === RED ? 'Đen' : 'Đỏ'} thắng!`);
                } else {
                    showRiverAlert();
                }
            }
        }

        function updateStatus() {
            statusEl.innerText = `Lượt: ${turn === RED ? 'Đỏ' : 'Đen'}`;
            statusEl.className = `text-sm font-bold bg-white px-3 py-1 rounded-full shadow-sm border ${turn === RED ? 'text-red-600 border-red-200' : 'text-gray-800 border-gray-200'}`;
        }

        function showAlert(title, msg) {
            document.getElementById('alert-title').innerText = title;
            document.getElementById('alert-message').innerText = msg;
            document.getElementById('alert-modal').classList.remove('hidden');
        }

        function closeAlert() { document.getElementById('alert-modal').classList.add('hidden'); }

        document.getElementById('reset-btn').onclick = () => {
    if (isOnline && conn && conn.open) {
        // Nếu là online, gửi yêu cầu chứ không reset ngay
        conn.send({ type: 'REQUEST_RESET' });
        showAlert("Đã gửi yêu cầu", "Đang chờ đối thủ đồng ý chơi lại...");
    } else {
        // Nếu là offline, reset bình thường
        initGame();
    }
    };
        window.onload = initGame;
    
    function connectToPeer(id) {
    conn = peer.connect(id);
    setupConnHandlers();
}

function setupConnHandlers() {
    conn.on('open', () => {
    console.log("Đã kết nối với: " + conn.peer);
    document.getElementById('waiting-msg').classList.add('hidden');
    if (myColor === BLACK) {
        showAlert("Đã kết nối!", "Bạn cầm quân Đen. Chờ Đỏ đi trước.");
    } else {
        showAlert("Đối thủ đã vào!", "Trận đấu bắt đầu. Bạn cầm quân Đỏ.");
    }
    // Cập nhật lại giao diện để xóa các thông báo chờ (nếu có)
    updateStatus();
});

    conn.on('data', (data) => {
        if (data.type === 'MOVE') {
            // Thực hiện nước đi từ đối thủ gửi tới
            executeMove(data.fromR, data.fromC, data.toR, data.toC);
        }
        else if (data.type === 'REQUEST_RESET') {
            // Khi nhận được yêu cầu, hiện Modal
            showConfirmModal((agreed) => {
                if (agreed) {
                    conn.send({ type: 'RESPONSE_RESET', agreed: true });
                    initGame(); //
                    showAlert("Bắt đầu!", "Ván chơi đã được làm mới.");
                } else {
                    conn.send({ type: 'RESPONSE_RESET', agreed: false });
                }
            });
        }
        else if (data.type === 'RESPONSE_RESET') {
            closeAlert(); //
            if (data.agreed) {
                initGame(); //
                showAlert("Thành công", "Đối thủ đã chấp nhận. Ván mới bắt đầu!");
            } else {
                showAlert("Từ chối", "Đối thủ không đồng ý chơi lại lúc này.");
            }
        }
    });
    conn.on('close', () => {
        showAlert("Mất kết nối", "Đối thủ đã rời phòng.");
    });
    conn.on('close', () => {
        if (myColor === BLACK) {
            // Nếu tôi là quân Đen (người tham gia), tức là Chủ phòng đã thoát
            showAlert("Mất kết nối", "Chủ phòng đã rời đi. Đang quay lại menu...");
            setTimeout(() => {
                window.location.href = 'index.html'; // Quay về menu chính
            }, 3000);
        } else {
            // Nếu tôi là quân Đỏ (chủ phòng), tức là đối thủ đã thoát
            showAlert("Đối thủ đã rời đi", "Phòng sẽ được làm mới để chờ người chơi mới.");
            setTimeout(() => {
                initGame(); // Làm mới bàn cờ
                // Hiển thị lại thông báo chờ nếu cần
                if (isOnline) {
                    document.getElementById('waiting-msg').classList.remove('hidden');
                }
            }, 3000);
        }
    });
}



// Hàm hiển thị Modal xác nhận
function showConfirmModal(callback) {
    const modal = document.getElementById('confirm-modal');
    modal.classList.remove('hidden');
    
    document.getElementById('confirm-yes').onclick = () => {
        modal.classList.add('hidden');
        callback(true);
    };
    
    document.getElementById('confirm-no').onclick = () => {
        modal.classList.add('hidden');
        callback(false);
    };
}
    </script>
    <!--------------------------------------------------------->
    
</body>
</html>